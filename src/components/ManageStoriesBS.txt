import React, { useState, useEffect } from "react";
import SideMenuTeacher from "./SideMenuTeacher";
import TopNavbar from "./TopNavbar";
import { useNavigate } from "react-router-dom";
import {
  Table,
  Button,
  InputGroup,
  FormControl,
  Container,
  Row,
  Col,
  Modal,
  Form,
  Dropdown,
  Alert,
  Spinner,
  Card,
  Badge,
} from "react-bootstrap";
import {
  PlusCircleFill,
  Search,
  ArrowLeftCircleFill,
  ThreeDotsVertical,
  Camera,
  PencilFill,
  TrashFill,
  BookFill,
  FileEarmarkPdfFill,
} from "react-bootstrap-icons";
import { db, storage, app as firebaseApp } from "../config/FirebaseConfig.js"; 
import { getFunctions, httpsCallable, } from "firebase/functions"; 
import {
  collection,
  getDocs,
  setDoc,
  updateDoc,
  deleteDoc,
  doc,
  serverTimestamp,
} from "firebase/firestore";
import { ref, uploadBytes, getDownloadURL, } from "firebase/storage";
import { getDoc } from "firebase/firestore";

// Converts PDF pages → PNG images → uploads to Firebase Storage → returns URLs
export async function convertAndUploadPdfPages(pdfFile, storyId, storage) {
  const arrayBuffer = await pdfFile.arrayBuffer();
  const pdfjsLib = await import("pdfjs-dist");
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

  const pagePromises = [];
  for (let i = 1; i <= pdf.numPages; i++) {
    pagePromises.push(
      (async (pageNum) => {
        const page = await pdf.getPage(pageNum);
        const viewport = page.getViewport({ scale: 2 });
        const canvas = document.createElement("canvas");
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        const context = canvas.getContext("2d");

        await page.render({ canvasContext: context, viewport }).promise;

        const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
        const imageRef = ref(storage, `story_pages/${storyId}/page_${pageNum}.png`);
        await uploadBytes(imageRef, blob);
        const url = await getDownloadURL(imageRef);

        return { pageNum, url };
      })(i)
    );
  }

  const pageResults = await Promise.all(pagePromises);
  return pageResults.sort((a, b) => a.pageNum - b.pageNum).map((res) => res.url);
}


// // Extracts text from each page of a PDF file and returns an array of strings
// export async function extractPdfPageTexts(pdfFile) {
//   const arrayBuffer = await pdfFile.arrayBuffer();
//   const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
//   const pageTexts = [];
//   for (let i = 1; i <= pdf.numPages; i++) {
//     const page = await pdf.getPage(i);
//     const textContent = await page.getTextContent();
//     const pageText = textContent.items.map((item) => item.str).join(" ").trim();
//     pageTexts.push(pageText);
//   }
//   return pageTexts;
// }

const functions = getFunctions(firebaseApp);
const generateMoralLessonAI = httpsCallable(functions, 'generateMoralLessonFromText');
const generateStorySynopsis = httpsCallable(functions, 'generateStorySynopsisFromPdf');
const generateQuestions = httpsCallable(functions, 'generateComprehensionQuestionsFromText');
const extractTextWithVision = httpsCallable(functions, "extractTextWithVision");
const translatePageTexts = httpsCallable(functions, 'translatePageTexts');
const generateAndStoreTts = httpsCallable(functions, 'generateAndStoreTts');

// pdfjsLib.GlobalWorkerOptions.workerSrc = `${process.env.PUBLIC_URL}/pdf.worker.min.js`;

const formatDate = (timestamp) => {
  if (!timestamp) return "N/A";
  try {
    const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
    if (isNaN(date.getTime())) {
      console.warn("Invalid date encountered:", timestamp);
      return "Invalid Date";
    }
    return date.toLocaleDateString(); 
  } catch (error) {
    console.error("Error formatting date:", timestamp, error);
    return "Error Date";
  }
};

const MAX_TTS_CHARS = 1500;

function splitTextForTTS(text, maxLength = MAX_TTS_CHARS) {
  const chunks = [];
  let current = 0;
  while (current < text.length) {
    chunks.push(text.substring(current, current + maxLength));
    current += maxLength;
  }
  return chunks;
}

const ManageStories = () => {
  const [showSidebar, setShowSidebar] = useState(false);
  const [showModal, setShowModal] = useState(false);
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [selectedStory, setSelectedStory] = useState(null);
  const [isEditing, setIsEditing] = useState(false);
  const [searchTerm, setSearchTerm] = useState("");
  const [alert, setAlert] = useState({ show: false, message: "", type: "" });
  const [isSubmitting, setIsSubmitting] = useState(false);

  const [isGeneratingMoral, setIsGeneratingMoral] = useState(false);
  const [stories, setStories] = useState([]);

  const [formData, setFormData] = useState({
    title: "",
    author: "",
    category: "",
    imageFile: null,
    imagePreviewUrl: "",
    pdfFile: null,
    pdfPreviewName: "",
    moralQuestion: "",
    moralOptions: ["", "", ""],
    moralCorrectOptionIndex: null,
    moralImageFile: null,
    moralImagePreviewUrl: "", // For moral lesson image
    comprehensionQuestions: [], // To hold comprehension questions
    language: "en-US", // Changed from languageCode
  });

  const [formErrors, setFormErrors] = useState({});

  // const generateFeedbackTTS = async () => {
  //   try {
  //       const generateAndStoreTts = httpsCallable(functions, 'generateAndStoreTts');
  //       await generateAndStoreTts({ text: "Correct! Well done.", fileName: "congratulations" });
  //       await generateAndStoreTts({ text: "Not quite right. Think about the story again.", fileName: "encouragement" });
  //       showAlert("Feedback TTS generated successfully!");
  //   } catch (error) {
  //       showAlert("Error generating feedback TTS: " + error.message, "danger");
  //   }
  // };

  const navigate = useNavigate();

  const COLORS = {
    primary: "#FF69B4",
    secondary: "#FFB6C1", 
    success: "#98FB98",
    danger: "#FFB6C1",
    warning: "#FFB6C1",
    info: "#FF69B4",
    light: "#FFF0F5",
    dark: "#2D2D2D",
    pink: "#FF69B4",
    lightPink: "#FFE4E1",
    softPink: "#FFF0F5",
  };

  useEffect(() => {
    fetchStoriesFromFirestore();
  }, []);

  const fetchStoriesFromFirestore = async () => {
    try {
      const querySnapshot = await getDocs(collection(db, "stories"));
      const storiesArr = querySnapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      setStories(storiesArr);
    } catch (error) {
      console.error("Error fetching stories:", error);
      setStories([]);
    }
  };

  const showAlert = (message, type = "success") => {
    setAlert({ show: true, message, type });
    setTimeout(() => {
      setAlert({ show: false, message: "", type: "" });
    }, 3500);
  };

  const toggleSidebar = () => {
    setShowSidebar(!showSidebar);
  };

  const validateForm = () => {
    const errors = {};

    if (!formData.title.trim()) {
      errors.title = "Title is required";
    }

    if (!formData.author.trim()) {
      errors.author = "Author is required";
    }

    if (!formData.category.trim()) {
      errors.category = "Category is required";
    }

    if (formData.moralQuestion.trim() &&
        (!formData.moralOptions.every(opt => opt && opt.trim() !== "") ||
         formData.moralOptions.length !== 3 ||
         formData.moralCorrectOptionIndex === null)) {
      errors.moralLesson = "If a moral question is provided, all options must be filled and a correct answer selected.";
    }

    setFormErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const handleOpenModal = () => {
    setFormData({
      title: "",
      author: "",
      category: "",
      imageFile: null,
      imagePreviewUrl: "",
      pdfFile: null,
      pdfPreviewName: "",
      moralQuestion: "",
      moralOptions: ["", "", ""],
      moralCorrectOptionIndex: null,
      moralImageFile: null,
      moralImagePreviewUrl: "", // For moral lesson image
      comprehensionQuestions: [], // To hold comprehension questions
      language: "en-US", // Changed from languageCode
    });
    setFormErrors({});
    setIsEditing(false);
    setShowModal(true);
  };

  const resetFormAndCloseModal = () => {
    setShowModal(false);
    setFormData({
      title: "",
      author: "",
      category: "",
      imageFile: null,
      imagePreviewUrl: "",
      pdfFile: null,
      pdfPreviewName: "",
      moralQuestion: "",
      moralOptions: ["", "", ""],
      moralCorrectOptionIndex: null,
      moralImageFile: null,
      moralImagePreviewUrl: "",
      language: "en-US",
    });
    setFormErrors({});
    setIsEditing(false);
    setSelectedStory(null);
  };

  const handleCloseModal = () => {
    const confirmClose = window.confirm("Are you sure you want to cancel? Any unsaved changes will be lost.");
    if (confirmClose) {
      resetFormAndCloseModal();
    }
  };

  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData({
      ...formData,
      [name]: value,
    });

    if (formErrors[name]) {
      setFormErrors({
        ...formErrors,
        [name]: "",
      });
    }
  };

  const handleImageUpload = (e) => {
    if (e.target.files && e.target.files[0]) {
      const file = e.target.files[0];
      if (file.size > 5 * 1024 * 1024) {
        showAlert("Image size should be less than 5MB", "danger");
        return;
      }
      setFormData({
        ...formData,
        imageFile: file,
      });
    }
  };

  const handleAssessmentImageUpload = (e, questionType, index = null) => {
    const file = e.target.files[0];
    if (!file) return;

    if (file.size > 2 * 1024 * 1024) { // 2MB limit
        showAlert("Image size should not exceed 2MB.", "danger");
        return;
    }

    if (questionType === 'moralLesson') {
        setFormData(prev => ({
            ...prev,
            moralImageFile: file,
            moralImagePreviewUrl: URL.createObjectURL(file)
        }));
    } else if (questionType === 'comprehensionQuestions' && index !== null) {
        const updatedQuestions = [...formData.comprehensionQuestions];
        if (updatedQuestions[index]) {
            updatedQuestions[index].imageFile = file;
            updatedQuestions[index].imagePreviewUrl = URL.createObjectURL(file);
        }
        setFormData(prev => ({ ...prev, comprehensionQuestions: updatedQuestions }));
    }
  };

const handlePdfUpload = async (e) => {
  if (e.target.files && e.target.files[0]) {
    const file = e.target.files[0];
    if (file.type !== "application/pdf") {
      showAlert("Please select a PDF file.", "danger");
      return;
    }
    if (file.size > 50 * 1024 * 1024) {
      showAlert("PDF size should be less than 50MB", "danger");
      return;
    }

    const storyId = doc(collection(db, "stories")).id;

    try {
      // Upload PDF to Firebase Storage
      const pdfRef = ref(storage, `story_pdfs/${storyId}_${file.name}`);
      await uploadBytes(pdfRef, file);
      const pdfUrl = await getDownloadURL(pdfRef);

      showAlert("Running OCR with Vision AI...", "info");

      // Call Vision OCR function
      const result = await extractTextWithVision({
        storyId,
        pdfStoragePath: `story_pdfs/${storyId}_${file.name}`,
      });

      const extractedText = result.data.text || "";

      console.log("Extracted text (Vision AI):", extractedText);

      // Generate AI moral lesson & questions
      let finalMoralLesson = {};
      let finalComprehensionQuestions = [];

      if (extractedText.trim()) {
        const [moralLessonResult, questionsResult] = await Promise.all([
          generateMoralLessonAI({ text: extractedText }),
          generateQuestions({ text: extractedText }),
        ]);

        finalMoralLesson = moralLessonResult.data || {};
        finalComprehensionQuestions = questionsResult.data.questions || [];
      }

      setFormData(prev => ({
        ...prev,
        pdfFile: file,
        pdfPreviewName: file.name,
        moralQuestion: finalMoralLesson.question || "",
        moralOptions: finalMoralLesson.options || ["", "", ""],
        moralCorrectOptionIndex: finalMoralLesson.correctOptionIndex ?? null,
        comprehensionQuestions: finalComprehensionQuestions,
      }));

      showAlert("OCR + AI generation complete!", "success");
    } catch (err) {
      console.error("OCR/AI error:", err);
      showAlert("Failed to process with Vision AI: " + err.message, "danger");
    }
  }
};


/**
 * Generates TTS audio for a given set of page texts and language.
 * @param {string[]} texts - Array of texts for each page.
 * @param {string} languageCode - The language code for TTS (e.g., 'en-US').
 * @param {string} storyId - The ID of the story to associate the audio with.
 * @returns {Promise<{audioData: object[], failedPages: number[]}>}
 */
const generateTtsForLanguage = async (texts, languageCode, storyId) => {
  const synthesizeSpeech = httpsCallable(functions, "synthesizeSpeechGoogle");
  const audioPromises = [];
  const failedPages = [];

  for (let i = 0; i < texts.length; i++) {
    const textToSpeak = texts[i];
    const pageNumber = i + 1;

    if (!textToSpeak || !textToSpeak.trim()) {
      failedPages.push(pageNumber);
      continue;
    }

    const ttsChunks = splitTextForTTS(textToSpeak);
    ttsChunks.forEach((chunk, chunkIdx) => {
      const promise = synthesizeSpeech({ text: chunk, languageCode })
        .then(async (result) => {
          if (!result.data || !result.data.audioData || typeof result.data.audioData !== "string") {
            console.warn(`Invalid audio data for page ${pageNumber} (lang: ${languageCode}), skipping.`);
            failedPages.push(pageNumber);
            return null;
          }
          const byteCharacters = atob(result.data.audioData);
          const byteNumbers = Array.from(byteCharacters, (char) => char.charCodeAt(0));
          const byteArray = new Uint8Array(byteNumbers);
          const audioBlob = new Blob([byteArray], { type: "audio/mp3" });
          const audioRef = ref(storage, `story_tts/${storyId}/page_${pageNumber}_chunk${chunkIdx + 1}_${languageCode}.mp3`);
          await uploadBytes(audioRef, audioBlob);
          const audioUrl = await getDownloadURL(audioRef);
          return { audioUrl, timepoints: result.data.timepoints || [], pageNumber };
        })
        .catch((err) => {
          console.error(`Error generating TTS for page ${pageNumber} (lang: ${languageCode}):`, err);
          failedPages.push(pageNumber);
          return null;
        });
      audioPromises.push(promise);
    });
  }

  const audioDataResults = await Promise.all(audioPromises);
  return {
    audioData: audioDataResults.filter(Boolean),
    failedPages: [...new Set(failedPages)],
  };
};

/**
 * Uploads an image for an assessment question to Firebase Storage.
 * @param {File} file The image file to upload.
 * @param {string} storyId The ID of the story.
 * @param {string} type The type of question ('moral' or 'comprehension').
 * @param {number} index The index of the question.
 * @returns {Promise<string|null>} The download URL of the uploaded image.
 */
const uploadAssessmentImage = async (file, storyId, type, index) => {
    if (!file) return null;
    const filePath = `assessment_images/${storyId}/${type}_${index}_${Date.now()}_${file.name}`;
    const imageRef = ref(storage, filePath);
    await uploadBytes(imageRef, file);
    return getDownloadURL(imageRef);
};

/**
 * Generates TTS audio for a single question and uploads it.
 * @param {string} text The text of the question.
 * @param {string} languageCode The language for TTS.
 * @param {string} storyId The story ID.
 * @param {string} type 'moral' or 'comprehension'.
 * @param {number} index The question index.
 * @returns {Promise<string|null>} The audio URL or null on failure.
 */
const generateQuestionTTS = async (text, languageCode, storyId, type, index) => {
    if (!text || !text.trim()) return null;

    try {
        const synthesizeSpeech = httpsCallable(functions, "synthesizeSpeechGoogle");
        const result = await synthesizeSpeech({ text, languageCode });

        if (!result.data || !result.data.audioData) throw new Error("Invalid audio data from TTS function.");

        const byteCharacters = atob(result.data.audioData);
        const byteNumbers = Array.from(byteCharacters, (char) => char.charCodeAt(0));
        const byteArray = new Uint8Array(byteNumbers);
        const audioBlob = new Blob([byteArray], { type: "audio/mp3" });
        const audioRef = ref(storage, `assessment_audio/${storyId}/${type}_${index}.mp3`);
        await uploadBytes(audioRef, audioBlob);
        return await getDownloadURL(audioRef);
    } catch (error) {
        console.error(`Error generating TTS for ${type} question ${index}:`, error);
        return null;
    }
};

const handleSubmit = async () => {
  if (!validateForm()) {
    showAlert("Please fill in all required fields", "danger");
    return;
  }
  setIsSubmitting(true);

  let finalPdfUrl = isEditing && selectedStory ? selectedStory.pdfUrl || "" : "";
  let finalImageUrl = isEditing && selectedStory ? selectedStory.image || "" : "";

  try {
    const storyId = isEditing && selectedStory 
      ? selectedStory.id 
      : doc(collection(db, "stories")).id;

    // --- Upload image & PDF ---
    const uploadTasks = [];
    if (formData.imageFile) {
      uploadTasks.push(uploadImageAndGetUrl(formData.imageFile, storyId));
    } else {
      uploadTasks.push(Promise.resolve(finalImageUrl));
    }
    if (formData.pdfFile) {
      uploadTasks.push(uploadPdfAndGetUrl(formData.pdfFile, storyId));
    } else {
      uploadTasks.push(Promise.resolve(finalPdfUrl));
    }

    let [uploadedImageUrl, uploadedPdfUrl] = await Promise.all(uploadTasks);
    finalImageUrl = uploadedImageUrl;
    finalPdfUrl = uploadedPdfUrl;

    // --- Base story payload ---
    const storyDataPayload = {
      title: formData.title,
      author: formData.author,
      category: formData.category,
      pdfUrl: finalPdfUrl,
      image: finalImageUrl,
      language: formData.language,
      comprehensionQuestions:
        Array.isArray(formData.comprehensionQuestions) &&
        formData.comprehensionQuestions.length === 3
          ? formData.comprehensionQuestions
          : [],
    };

    // --- Moral lesson (with TTS + optional image) ---
    if (
      formData.moralQuestion &&
      formData.moralOptions.every((opt) => opt && opt.trim() !== "") &&
      formData.moralCorrectOptionIndex !== null
    ) {
      const moralAudioUrl = await generateQuestionTTS(
        formData.moralQuestion.trim(),
        formData.language,
        storyId,
        "moral",
        0
      );
      storyDataPayload.moralLesson = {
        question: formData.moralQuestion.trim(),
        options: formData.moralOptions.map((opt) => opt.trim()),
        correctOptionIndex: formData.moralCorrectOptionIndex,
        audioUrl: moralAudioUrl,
      };
    } else {
      if (isEditing && selectedStory && selectedStory.moralLesson) {
        storyDataPayload.moralLesson = null;
      }
    }

    if (formData.moralImageFile) {
      const url = await uploadAssessmentImage(formData.moralImageFile, storyId, "moral", 0);
      if (url && storyDataPayload.moralLesson) {
        storyDataPayload.moralLesson.imageUrl = url;
      }
    } else if (isEditing && selectedStory.moralLesson?.imageUrl) {
      if (storyDataPayload.moralLesson) {
        storyDataPayload.moralLesson.imageUrl = selectedStory.moralLesson.imageUrl;
      }
    }

    // --- Comprehension questions (with TTS + optional image) ---
    if (
      Array.isArray(formData.comprehensionQuestions) &&
      formData.comprehensionQuestions.length > 0
    ) {
      const processedQuestions = await Promise.all(
        formData.comprehensionQuestions.map(async (q, index) => {
          let finalImageUrl = q.imageUrl || null;
          if (q.imageFile) {
            const newUrl = await uploadAssessmentImage(q.imageFile, storyId, "comprehension", index);
            if (newUrl) finalImageUrl = newUrl;
          }
          const questionAudioUrl = await generateQuestionTTS(
            q.question,
            formData.language,
            storyId,
            "comprehension",
            index
          );
          return {
            question: q.question,
            options: q.options,
            correctOptionIndex: q.correctOptionIndex,
            imageUrl: finalImageUrl,
            audioUrl: questionAudioUrl,
          };
        })
      );
      storyDataPayload.comprehensionQuestions = processedQuestions;
    }

    // --- Save story doc (new or update) ---
    let randomStoryId, storyRef;
    if (isEditing && selectedStory) {
      storyRef = doc(db, "stories", selectedStory.id);
      storyDataPayload.dateModified = serverTimestamp();
      await updateDoc(storyRef, storyDataPayload);
      randomStoryId = selectedStory.id;
    } else {
      storyDataPayload.createdAt = serverTimestamp();
      storyDataPayload.dateModified = serverTimestamp();
      randomStoryId = storyId;
      storyRef = doc(db, "stories", storyId);
      storyDataPayload.storyId = storyId;
      await setDoc(storyRef, storyDataPayload);
    }

    // --- Process PDF: images + Vision OCR text ---
    if (formData.pdfFile && randomStoryId) {
      try {
        showAlert("Splitting PDF into images and extracting text...", "info");

        // Convert pages -> images
        const imageUrls = await convertAndUploadPdfPages(formData.pdfFile, randomStoryId, storage);

        // Get Vision OCR page texts from Firestore
        let pageTexts = [];
        try {
          const storySnap = await getDoc(doc(db, "stories", randomStoryId));
          if (storySnap.exists()) {
            const storyData = storySnap.data();
            if (Array.isArray(storyData.pageTexts)) {
              pageTexts = storyData.pageTexts;
            } else if (storyData.extractedText) {
              pageTexts = [storyData.extractedText];
            }
          }
        } catch (err) {
          console.error("Error fetching extractedText from Firestore:", err);
        }

        // --- Translation ---
        showAlert("Translating page content...", "info");
        const sourceLang = formData.language;
        const targetLang = sourceLang === "en-US" ? "tl" : "en";
        const targetLangCode = sourceLang === "en-US" ? "fil-PH" : "en-US";

        let translatedTexts = [];
        try {
          const translationResult = await translatePageTexts({
            texts: pageTexts,
            targetLanguage: targetLang,
          });
          translatedTexts = translationResult.data.translatedTexts;

          await updateDoc(doc(db, "stories", randomStoryId), {
            translations: { [targetLangCode]: translatedTexts },
          });
          showAlert("Page content translated successfully!", "success");
        } catch (translationError) {
          console.error("Translation failed:", translationError);
          showAlert(`Translation failed: ${translationError.message}`, "danger");
        }

        // --- Bilingual TTS ---
        showAlert("Generating audio for all languages...", "info");
        const ttsPayload = {};

        const sourceTtsResult = await generateTtsForLanguage(
          pageTexts,
          sourceLang,
          randomStoryId
        );
        ttsPayload[sourceLang] = sourceTtsResult.audioData;
        if (sourceTtsResult.failedPages.length > 0) {
          showAlert(
            `TTS failed for some pages in ${sourceLang}: ${sourceTtsResult.failedPages.join(", ")}`,
            "warning"
          );
        }

        if (translatedTexts.length > 0) {
          const targetTtsResult = await generateTtsForLanguage(
            translatedTexts,
            targetLangCode,
            randomStoryId
          );
          ttsPayload[targetLangCode] = targetTtsResult.audioData;
          if (targetTtsResult.failedPages.length > 0) {
            showAlert(
              `TTS failed for some pages in ${targetLangCode}: ${targetTtsResult.failedPages.join(", ")}`,
              "warning"
            );
          }
        }

        await updateDoc(doc(db, "stories", randomStoryId), {
          pageImages: imageUrls,
          pageTexts,
          ttsAudio: ttsPayload,
        });

        showAlert("PDF processed and all audio generated.", "success");
      } catch (err) {
        showAlert("Failed to split PDF into pages: " + err.message, "danger");
      }
    }

    // --- Trigger synopsis in background ---
    if (finalPdfUrl && randomStoryId) {
      showAlert("Synopsis generation initiated in the background...", "info");
      await generateStorySynopsis({ storyId: randomStoryId })
        .then(() => {
          showAlert(
            "Synopsis generation process completed. It will appear in the story details soon.",
            "success"
          );
        })
        .catch((error) => {
          console.error("Error calling generateStorySynopsis function:", error);
          showAlert(`Synopsis generation failed to start: ${error.message}`, "danger");
        });
    }

    fetchStoriesFromFirestore();
    resetFormAndCloseModal();
  } catch (error) {
    showAlert("Error saving story: " + error.message, "danger");
    console.error("Error saving story:", error);
  } finally {
    setIsSubmitting(false);
  }
};


  const uploadImageAndGetUrl = async (file, storyId) => {
    if (!file) return "";
    const imageRef = ref(storage, `stories/${storyId}_${file.name}`);
    await uploadBytes(imageRef, file);
    return await getDownloadURL(imageRef);
  };

  const uploadPdfAndGetUrl = async (file, storyId) => {
    if (!file) return "";
    const pdfRef = ref(storage, `story_pdfs/${storyId}_${file.name}`);
    await uploadBytes(pdfRef, file);
    return await getDownloadURL(pdfRef);
  };

  const handleEditStory = (story) => {
    setSelectedStory(story);
    setFormData(prev => ({
      ...prev,
      title: story.title,
      author: story.author,
      category: story.category,
      imagePreviewUrl: story.image || "",
      pdfPreviewName: story.pdfUrl || "",
      moralQuestion: story.moralLesson?.question || "",
      moralOptions: (story.moralLesson?.options && story.moralLesson.options.length === 3)
        ? story.moralLesson.options
        : ["", "", ""],
      moralImagePreviewUrl: story.moralLesson?.imageUrl || "", // Populate image preview
      moralCorrectOptionIndex: story.moralLesson?.correctOptionIndex !== undefined ? story.moralLesson.correctOptionIndex : null,
      comprehensionQuestions: story.comprehensionQuestions || [],
      language: story.language || "en-US",
    }));
    setFormErrors({});
    setIsEditing(true);
    setShowModal(true);
  };


  const handleDeleteClick = (story) => {
    setSelectedStory(story);
    setShowDeleteModal(true);
  };

  const confirmDelete = async () => {
    try {
      await deleteDoc(doc(db, "stories", selectedStory.id));
      setShowDeleteModal(false);
      showAlert("Story deleted successfully!", "success");
      fetchStoriesFromFirestore();
    } catch (error) {
      showAlert("Error deleting story", "danger");
      console.error(error);
    }
  };

  const handleSearchChange = (e) => {
    setSearchTerm(e.target.value);
  };

  const filteredStories = stories.filter(
    (story) =>
      (story.title || "").toLowerCase().includes(searchTerm.toLowerCase()) ||
      (story.author || "").toLowerCase().includes(searchTerm.toLowerCase()) ||
      (story.category || "").toLowerCase().includes(searchTerm.toLowerCase())
  );

  const getCategoryColor = (category) => {
    const colorMap = {
      'Fables': '#FF69B4',
      'Fantasy': '#FFB6C1',
      'Folktales': '#DDA0DD',
      'Inspirational': '#FF91A4',
      'Legend': '#F08080'
    };
    return colorMap[category] || COLORS.pink;
  };

  return (
    <div className="app-container" style={{ overflow: "hidden", height: "100vh" }}>
      <style jsx>{`
        .action-button:hover {
          background-color: ${COLORS.pink} !important;
          color: white !important;
          transform: scale(1.05);
          box-shadow: 0 4px 12px rgba(255, 105, 180, 0.3);
        }
        .dropdown-item:hover {
          background-color: #FFF0F5 !important;
          color: ${COLORS.pink} !important;
        }
        .min-width-0 { min-width: 0; }
        .flex-shrink-0 { flex-shrink: 0; }
        .text-truncate {
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }
      `}</style>

      <TopNavbar toggleSidebar={toggleSidebar} />

      <div className="content-container" style={{ display: "flex", height: "calc(100vh - 56px)" }}>
        <div className={`sidebar-container ${showSidebar ? "show" : ""}`}>
          <SideMenuTeacher isOpen={showSidebar} toggleSidebar={toggleSidebar} />
        </div>
        
        <Container
          fluid
          className={`main-content ${showSidebar ? "shifted" : ""}`}
          style={{
            overflowY: "auto",
            padding: "24px",
            height: "calc(100vh - 56px)",
            flex: 1,
            background: 'linear-gradient(135deg, #FFF5F8 0%, #FFE8F1 50%, #F8E8FF 100%)',
          }}
        >
          {/* Alert */}
          <Alert
            show={alert.show}
            variant={alert.type === "danger" ? "danger" : "success"}
            onClose={() => setAlert({ ...alert, show: false })}
            dismissible
            style={{
              position: "fixed",
              top: "80px",
              right: "20px",
              zIndex: 9999,
              minWidth: "300px",
              maxWidth: "500px",
              boxShadow: "0 8px 25px rgba(0,0,0,0.15)",
              borderRadius: "8px",
            }}
          >
            {alert.message}
          </Alert>

          {/* Header */}
          <div className="d-flex justify-content-between align-items-center mb-4">
            <div className="d-flex align-items-center">
              <Button
                variant="link"
                onClick={() => navigate(-1)}
                className="me-3 p-0"
                style={{ color: COLORS.primary }}
              >
                <ArrowLeftCircleFill size={24} />
              </Button>
              <div>
                <h1 className="mb-1 fw-bold text-dark">Manage Stories</h1>
                <p className="text-muted mb-0">Create, edit, and manage story collections</p>
              </div>
            </div>
            <div className="d-flex align-items-center gap-2">
              <InputGroup style={{ width: "300px" }}>
                <FormControl
                  placeholder="Search stories..."
                  value={searchTerm}
                  onChange={handleSearchChange}
                  className="border-0 shadow-sm"
                  style={{ 
                    borderRadius: "25px 0 0 25px",
                    border: `1px solid ${COLORS.secondary}`,
                    borderRight: "none"
                  }}
                />
                <InputGroup.Text 
                  className="shadow-sm"
                  style={{ 
                    borderRadius: "0 25px 25px 0",
                    color: COLORS.pink,
                    borderLeft: "none"
                  }}
                >
                  <Search />
                </InputGroup.Text>
              </InputGroup>
              <Button
                onClick={handleOpenModal}
                className="d-flex align-items-center gap-2 shadow-sm"
                style={{
                  backgroundColor: COLORS.pink,
                  border: "none",
                  borderRadius: "25px",
                  padding: "10px 20px",
                  fontWeight: "500",
                }}
              >
                <PlusCircleFill size={18} />
                Add Story
              </Button>
              {/* <Button onClick={generateFeedbackTTS}>Generate Feedback TTS</Button> */}
            </div>
          </div>

          {/* Stats Cards */}
          <Row className="g-4 mb-4">
            <Col lg={3} md={6}>
              <Card className="shadow-sm h-100 border-0" style={{ borderRadius: "12px" }}>
                <Card.Body className="p-4 d-flex align-items-center">
                  <BookFill size={32} color={COLORS.pink} className="me-3" />
                  <div>
                    <div className="text-muted mb-2 fs-6">Total Stories</div>
                    <h3 className="mb-0 fw-bold text-dark">{stories.length}</h3>
                  </div>
                </Card.Body>
              </Card>
            </Col>
            <Col lg={3} md={6}>
              <Card className="shadow-sm h-100 border-0" style={{ borderRadius: "12px" }}>
                <Card.Body className="p-4 d-flex align-items-center">
                  <FileEarmarkPdfFill size={32} color={COLORS.secondary} className="me-3" />
                  <div>
                    <div className="text-muted mb-2 fs-6">Published Stories</div>
                    <h3 className="mb-0 fw-bold text-dark">
                      {stories.filter(s => s.pdfUrl).length}
                    </h3>
                  </div>
                </Card.Body>
              </Card>
            </Col>
            <Col lg={3} md={6}>
              <Card className="shadow-sm h-100 border-0" style={{ borderRadius: "12px" }}>
                <Card.Body className="p-4 d-flex align-items-center">
                  <BookFill size={32} color="#DDA0DD" className="me-3" />
                  <div>
                    <div className="text-muted mb-2 fs-6">Categories</div>
                    <h3 className="mb-0 fw-bold text-dark">
                      {[...new Set(stories.map(s => s.category))].length}
                    </h3>
                  </div>
                </Card.Body>
              </Card>
            </Col>
          </Row>

          {/* Content */}
          <Card className="shadow-sm border-0" style={{ borderRadius: "15px" }}>
            <Card.Header 
              className="border-0 py-4"
              style={{ 
                borderRadius: "15px 15px 0 0",
                backgroundColor: COLORS.light
              }}
            >
              <div className="d-flex justify-content-between align-items-center">
                <h5 className="mb-0 fw-semibold">
                  Stories Collection
                  <Badge 
                    className="ms-2"
                    style={{ 
                      backgroundColor: COLORS.pink, 
                      color: "white",
                      borderRadius: "12px",
                      padding: "4px 8px"
                    }}
                  >
                    {filteredStories.length}
                  </Badge>
                </h5>
                {searchTerm && (
                  <small className="text-muted">
                    Showing {filteredStories.length} of {stories.length} stories
                  </small>
                )}
              </div>
            </Card.Header>
            <Card.Body className="p-0">
              {filteredStories.length === 0 ? (
                <div className="text-center py-5">
                  <BookFill size={48} className="text-muted mb-3" opacity={0.3} />
                  <h5 className="text-muted mb-2">
                    {searchTerm ? "No stories found" : "No stories yet"}
                  </h5>
                  <p className="text-muted mb-3">
                    {searchTerm 
                      ? "Try adjusting your search terms" 
                      : "Get started by adding your first story"
                    }
                  </p>
                  {!searchTerm && (
                    <Button
                      onClick={handleOpenModal}
                      style={{
                        backgroundColor: COLORS.pink,
                        border: "none",
                        borderRadius: "25px",
                        padding: "10px 20px",
                      }}
                    >
                      <PlusCircleFill size={18} className="me-2" />
                      Add First Story
                    </Button>
                  )}
                </div>
              ) : (
                <Table responsive hover={false} className="mb-0" >
                  <thead>
                    <tr style={{ backgroundColor: '#FFF0F5'  }}>
                      <th className="border-0 py-4 fw-semibold" style={{ color: COLORS.pink, width: '30%', paddingLeft: '24px' }}>Story</th>
                      <th className="border-0 py-4 fw-semibold" style={{ color: COLORS.pink, width: '15%' }}>Author</th>
                      <th className="border-0 py-4 fw-semibold" style={{ color: COLORS.pink, width: '12%' }}>Category</th>
                      <th className="border-0 py-4 fw-semibold" style={{ color: COLORS.pink, width: '12%' }}>Date Added</th>
                      <th className="border-0 py-4 fw-semibold" style={{ color: COLORS.pink, width: '10%' }}>PDF</th>
                      <th className="border-0 py-4 fw-semibold text-center" style={{ color: COLORS.pink, width: '8%', paddingRight: '24px' }}>Actions</th>
                    </tr>
                  </thead>
                  <tbody>
                    {filteredStories.map((story, index) => (
                      <tr 
                        key={story.id}
                        style={{ 
                          backgroundColor: index % 2 === 0 ? '#FFFFFF' : '#FFF8FA',
                          borderBottom: '1px solid #FFE4E1'
                        }}
                      >
                        <td className="py-4 align-middle" style={{ paddingLeft: '24px',}}>
                          <div className="d-flex align-items-center">
                            <div 
                              className="rounded-circle d-flex align-items-center justify-content-center me-3 flex-shrink-0"
                              style={{ 
                                width: '48px', 
                                height: '48px',
                                background: story.image 
                                  ? `url(${story.image}) center/cover` 
                                  : `linear-gradient(135deg, ${COLORS.pink} 0%, ${COLORS.secondary} 100%)`,
                                boxShadow: '0 2px 8px rgba(255, 105, 180, 0.2)',
                                border: story.image ? 'none' : '2px solid #fff'
                              }}
                            >
                              {!story.image && <BookFill size={22} style={{ color: "white" }} />}
                            </div>
                            <div className="min-width-0 flex-grow-1">
                              <div className="fw-bold text-dark mb-1" style={{ fontSize: '0.95rem' }}>
                                {story.title}
                              </div>
                            </div>
                          </div>
                        </td>
                        <td className="py-4 align-middle">
                          <span 
                            className="text-dark fw-medium" 
                            style={{ fontSize: '0.9rem' }}
                          >
                            {story.author}
                          </span>
                        </td>
                        <td className="py-4 align-middle">
                          <Badge 
                            className="fw-semibold"
                            style={{ 
                              backgroundColor: getCategoryColor(story.category), 
                              color: 'white',
                              fontSize: '0.75rem',
                              borderRadius: '20px',
                              padding: '6px 12px',
                              border: 'none',
                              boxShadow: '0 2px 6px rgba(0,0,0,0.1)'
                            }}
                          >
                            {story.category}
                          </Badge>
                        </td>
                        <td className="py-4 align-middle">
                          <span 
                            className="text-dark" 
                            style={{ fontSize: '0.85rem' }}
                          >
                            {formatDate(story.createdAt)}
                          </span>
                        </td>
                        <td className="py-4 align-middle">
                          {story.pdfUrl ? (
                            <a
                              href={story.pdfUrl}
                              target="_blank"
                              rel="noopener noreferrer"
                              className="btn btn-sm"
                              style={{
                                backgroundColor: COLORS.lightPink,
                                color: COLORS.pink,
                                border: 'none',
                                borderRadius: '15px',
                                padding: '4px 12px',
                                fontSize: '0.75rem',
                                fontWeight: '500'
                              }}
                            >
                              <FileEarmarkPdfFill size={12} className="me-1" />
                              View
                            </a>
                          ) : (
                            <Badge 
                              className="fw-normal"
                              style={{ 
                                backgroundColor: '#f8f9fa', 
                                color: '#6c757d',
                                fontSize: '0.75rem',
                                borderRadius: '15px',
                                padding: '4px 8px',
                                border: '1px solid #dee2e6'
                              }}
                            >
                              None
                            </Badge>
                          )}
                        </td>
                        <td className="py-4 align-middle text-center" style={{ paddingRight: '24px' }}>
                          <Dropdown>
                            <Dropdown.Toggle
                              as="div"
                              className="btn btn-sm d-inline-flex align-items-center justify-content-center action-button"
                              style={{ 
                                width: '32px', 
                                height: '32px',
                                cursor: 'pointer',
                                backgroundColor: 'transparent',
                                color: COLORS.pink,
                                transition: 'all 0.2s ease',
                                border: `1px solid ${COLORS.pink}`,
                                borderRadius: '50%',
                              }}
                            >
                            </Dropdown.Toggle>
                            <Dropdown.Menu 
                              align="end" 
                              className="shadow border-0"
                              style={{
                                borderRadius: '12px',
                                overflow: 'hidden',
                                minWidth: '160px'
                              }}
                            >
                              <Dropdown.Item
                                onClick={() => handleEditStory(story)}
                                className="d-flex align-items-center py-3 px-4"
                                style={{
                                  transition: 'background-color 0.2s ease',
                                  borderRadius: '0'
                                }}
                              >
                                <PencilFill size={14} className="me-3" style={{ color: COLORS.pink }} />
                                <span style={{ fontSize: '0.9rem', fontWeight: '500' }}>Edit Story</span>
                              </Dropdown.Item>
                              <Dropdown.Divider style={{ margin: '0', backgroundColor: '#FFE4E1' }} />
                              <Dropdown.Item
                                onClick={() => handleDeleteClick(story)}
                                className="d-flex align-items-center py-3 px-4"
                                style={{ 
                                  color: COLORS.pink,
                                  transition: 'background-color 0.2s ease',
                                  borderRadius: '0'
                                }}
                              >
                                <TrashFill size={14} className="me-3" />
                                <span style={{ fontSize: '0.9rem', fontWeight: '500' }}>Delete Story</span>
                              </Dropdown.Item>
                            </Dropdown.Menu>
                          </Dropdown>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </Table>
              )}
            </Card.Body>
          </Card>
        </Container>
      </div>

      {/* Story Registration/Edit Modal */}
      <Modal show={showModal} onHide={handleCloseModal} size="lg" centered>
        <Modal.Header closeButton style={{ border: "none", background: `linear-gradient(135deg, ${COLORS.lightPink} 0%, ${COLORS.softPink} 100%)` }}>
          <Modal.Title className="w-100 text-center">
            <h3 className="mb-0 fw-bold" style={{ color: COLORS.pink }}>
              {isEditing ? "Edit Story" : "Story Registration"}
            </h3>
          </Modal.Title>
        </Modal.Header>
        
<Modal.Body className="p-4">
  {/* Top Section: Image Upload and Basic Form Fields */}
  <Row className="align-items-start mb-4">
    <Col md={4}>
      <div
        className="border-0 shadow-sm d-flex flex-column align-items-center justify-content-center p-4"
        style={{
          height: "100%",
          minHeight: "350px",
          cursor: "pointer",
          borderRadius: "15px",
          backgroundColor: COLORS.light,
          border: `2px dashed ${COLORS.secondary}`,
          transition: "all 0.3s ease"
        }}
        onClick={() => document.getElementById("imageUpload").click()}
      >
        {formData.imagePreviewUrl ? (
          <img 
            src={formData.imagePreviewUrl}
            alt="Preview"
            style={{
              maxWidth: "100%",
              maxHeight: "200px",
              objectFit: "contain",
              borderRadius: "12px"
            }}
          />
        ) : formData.imageFile ? (
          <img 
            src={URL.createObjectURL(formData.imageFile)}
            alt="Preview"
            style={{
              maxWidth: "100%",
              maxHeight: "200px",
              objectFit: "contain",
              borderRadius: "12px"
            }}
          />
        ) : (
          <>
            <div
              className="rounded-circle d-flex align-items-center justify-content-center mb-3"
              style={{
                width: "80px", 
                height: "80px",
                background: `linear-gradient(135deg, ${COLORS.pink} 0%, ${COLORS.secondary} 100%)`,
                boxShadow: '0 4px 15px rgba(255, 105, 180, 0.3)'
              }}
            >
              <Camera size={36} color="white" />
            </div>
            <p className="text-center mb-3 fw-medium" style={{ color: COLORS.dark }}>
              Upload Story Cover
              <br />
              <small className="text-muted">Click to browse files</small>
            </p>
          </>
        )}
        <input
          type="file"
          id="imageUpload"
          accept="image/*"
          className="d-none"
          key={formData.imagePreviewUrl}
          onChange={handleImageUpload}
        />
        <Button
          variant="link"
          className="p-0 fw-semibold"
          style={{ color: COLORS.pink, textDecoration: "none" }}
        >
          {formData.imageFile || formData.imagePreviewUrl
            ? "Change Image"
            : "Upload Image"}
        </Button>
      </div>
    </Col>
    <Col md={8}>
      <Form>
        <Row>
          <Col md={6}>
            <Form.Group className="mb-3">
              <Form.Label className="fw-semibold" style={{ color: COLORS.dark }}>
                Story Title *
              </Form.Label>
              <Form.Control
                type="text"
                name="title"
                value={formData.title || ""}
                onChange={handleInputChange}
                isInvalid={!!formErrors.title}
                placeholder="Enter story title"
                className="border-0 shadow-sm"
                style={{ borderRadius: "12px", padding: "12px 16px" }}
              />
              <Form.Control.Feedback type="invalid">
                {formErrors.title}
              </Form.Control.Feedback>
            </Form.Group>
          </Col>
          <Col md={6}>
            <Form.Group className="mb-3">
              <Form.Label className="fw-semibold" style={{ color: COLORS.dark }}>
                Author *
              </Form.Label>
              <Form.Control
                type="text"
                name="author"
                value={formData.author || ""}
                onChange={handleInputChange}
                isInvalid={!!formErrors.author}
                placeholder="Enter author name"
                className="border-0 shadow-sm"
                style={{ borderRadius: "12px", padding: "12px 16px" }}
              />
              <Form.Control.Feedback type="invalid">
                {formErrors.author}
              </Form.Control.Feedback>
            </Form.Group>
          </Col>
        </Row>

        <Row>
          <Col md={6}>
            <Form.Group className="mb-3">
              <Form.Label className="fw-semibold" style={{ color: COLORS.dark }}>
                Category *
              </Form.Label>
              <Form.Select
                name="category"
                value={formData.category}
                onChange={handleInputChange}
                isInvalid={!!formErrors.category}
                required
                className="border-0 shadow-sm"
                style={{ borderRadius: "12px", padding: "12px 16px" }}
              >
                <option value="">Select category</option>
                <option value="Fables">Fables</option>
                <option value="Fantasy">Fantasy</option>
                <option value="Folktales">Folktales</option>
                <option value="Inspirational">Inspirational</option>
                <option value="Legend">Legend</option>
              </Form.Select>
              <Form.Control.Feedback type="invalid">
                {formErrors.category}
              </Form.Control.Feedback>
            </Form.Group>
          </Col>
          <Col md={6}>
            <Form.Group className="mb-3">
              <Form.Label className="fw-semibold" style={{ color: COLORS.dark }}>
                Story Language *
              </Form.Label>
              <Form.Select
                name="language"
                value={formData.language || "en-US"}
                onChange={handleInputChange}
                required
                className="border-0 shadow-sm"
                style={{ borderRadius: "12px", padding: "12px 16px" }}
              >
                <option value="en-US">English</option>
                <option value="fil-PH">Filipino</option>
              </Form.Select>
            </Form.Group>
          </Col>
        </Row>

        <Form.Group className="mb-4">
          <Form.Label className="fw-semibold" style={{ color: COLORS.dark }}>
            Story PDF
          </Form.Label>
          <div 
            className="border-0 shadow-sm p-4 text-center"
            style={{
              borderRadius: "15px",
              backgroundColor: COLORS.light,
              border: `2px dashed ${COLORS.secondary}`
            }}
          >
            <FileEarmarkPdfFill size={32} color={COLORS.pink} className="mb-2" />
            <div className="mb-3">
              <Button
                variant="outline-primary"
                onClick={() => document.getElementById("pdfUpload").click()}
                className="me-2"
                style={{
                  borderColor: COLORS.pink,
                  color: COLORS.pink,
                  borderRadius: "20px",
                  padding: "8px 20px"
                }}
              >
                {formData.pdfFile
                  ? "Change PDF"
                  : formData.pdfPreviewName &&
                    formData.pdfPreviewName.startsWith("http")
                  ? "Replace PDF"
                  : "Upload PDF"}
              </Button>
              <input
                type="file"
                id="pdfUpload"
                accept=".pdf"
                className="d-none"
                key={formData.pdfPreviewName}
                onChange={handlePdfUpload}
                required
              />
            </div>
            {formData.pdfFile ? (
              <small className="text-muted d-block">
                Selected: <span className="fw-medium">{formData.pdfFile.name}</span>
              </small>
            ) : formData.pdfPreviewName &&
              formData.pdfPreviewName.startsWith("http") ? (
              <small className="text-muted d-block">
                Current: <a
                  href={formData.pdfPreviewName}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-decoration-none"
                  style={{ color: COLORS.pink }}
                >
                  {formData.pdfPreviewName
                    .substring(
                      formData.pdfPreviewName.lastIndexOf("/") + 1
                    )
                    .split("?")[0].split("%2F").pop() 
                    .substring(0, 30)}...
                </a>
              </small>
            ) : (
              <small className="text-muted">
                No PDF uploaded yet
              </small>
            )}
          </div>
          {formErrors.pdfFile && (
            <Form.Text className="text-danger">
              {formErrors.pdfFile}
            </Form.Text>
          )}
        </Form.Group>
      </Form>
    </Col>
  </Row>

  {/* Full Width Questions Section */}
  <div className="w-100">
    {/* Moral Lesson Section - Full Width */}
    <Card className="border-0 shadow-sm mb-4" style={{ borderRadius: "15px" }}>
      <Card.Header className="border-0" style={{ backgroundColor: COLORS.light, borderRadius: "15px 15px 0 0" }}>
        <h6 className="mb-0 fw-bold" style={{ color: COLORS.pink }}>
          Moral Lesson
          {isGeneratingMoral && (
            <Spinner animation="border" size="sm" className="ms-2" />
          )}
        </h6>
      </Card.Header>
      <Card.Body className="p-4">
        {isGeneratingMoral && (
          <div className="d-flex align-items-center mb-3 p-3" style={{ backgroundColor: '#f8f9fa', borderRadius: '10px' }}>
            <Spinner animation="border" size="sm" className="me-2" />
            <span className="text-muted">Generating moral lesson...</span>
          </div>
        )}
        
        {/* Question Field - Full Width */}
        <Form.Group className="mb-4">
          <Form.Label className="fw-semibold">Question</Form.Label>
          <Form.Control
            as="textarea"
            rows={3}
            name="moralQuestion"
            value={formData.moralQuestion || ""}
            onChange={handleInputChange}
            placeholder="e.g., What is the main lesson of the story?"
            disabled={isGeneratingMoral || isSubmitting}
            isInvalid={!!formErrors.moralLesson}
            className="border-0 shadow-sm"
            style={{ borderRadius: "12px" }}
          />
          <Form.Control.Feedback type="invalid" className={formErrors.moralLesson ? 'd-block' : ''}>
            {formErrors.moralLesson}
          </Form.Control.Feedback>
        </Form.Group>

        {/* Options - Full Width */}
        <Row className="g-3">
          {formData.moralOptions.map((option, index) => (
            <Col xs={12} key={`moral-option-${index}`}>
              <Form.Group>
                <Form.Label className="fw-medium">Option {String.fromCharCode(65 + index)}</Form.Label>
                <InputGroup>
                  <Form.Control
                    type="text"
                    value={option || ""}
                    onChange={(e) => {
                      const newOptions = [...formData.moralOptions];
                      newOptions[index] = e.target.value;
                      setFormData(prev => ({ ...prev, moralOptions: newOptions }));
                    }}
                    placeholder={`Enter option ${String.fromCharCode(65 + index)}`}
                    disabled={isGeneratingMoral || isSubmitting}
                    className="border-0 shadow-sm"
                    style={{ borderRadius: "12px 0 0 12px" }}
                  />
                  <InputGroup.Radio
                    name="correctMoralOption"
                    aria-label={`Set Option ${index + 1} as correct`}
                    checked={formData.moralCorrectOptionIndex === index}
                    onChange={() => setFormData(prev => ({ ...prev, moralCorrectOptionIndex: index }))}
                    disabled={isGeneratingMoral || isSubmitting}
                    style={{ 
                      backgroundColor: formData.moralCorrectOptionIndex === index ? COLORS.pink : 'transparent',
                      borderColor: COLORS.pink 
                    }}
                  />
                  <InputGroup.Text 
                    className="shadow-sm"
                    style={{ 
                      backgroundColor: formData.moralCorrectOptionIndex === index ? COLORS.pink : COLORS.light,
                      color: formData.moralCorrectOptionIndex === index ? 'white' :COLORS.dark,
                      borderRadius: "0 12px 12px 0",
                      borderColor: COLORS.pink,
                      fontWeight: '500',
                      fontSize: '0.85rem',
                      minWidth: "100px"
                    }}
                  >
                    {formData.moralCorrectOptionIndex === index ? "Correct" : "Incorrect"}
                  </InputGroup.Text>
                </InputGroup>
              </Form.Group>
            </Col>
          ))}
        </Row>
        
        {formErrors.moralLesson && !formData.moralQuestion.trim() && (
          <Form.Text className="text-danger d-block mt-3">
            {formErrors.moralLesson}
          </Form.Text>
        )}

        {/* Moral Lesson Image Upload */}
        <Form.Group className="mt-3">
          <Form.Label className="fw-medium">Question Image (Optional)</Form.Label>
          <Form.Control type="file" size="sm" accept="image/*" onChange={(e) => handleAssessmentImageUpload(e, 'moralLesson')} />
          {formData.moralImagePreviewUrl && (
            <div className="mt-2">
              <img 
                src={formData.moralImagePreviewUrl} 
                alt="Moral lesson preview" 
                style={{ width: '100px', height: '100px', objectFit: 'cover', borderRadius: '8px' }} 
              />
            </div>
          )}
        </Form.Group>

      </Card.Body>
    </Card>

    {/* Comprehension Questions Section - Full Width */}
    <Card className="border-0 shadow-sm" style={{ borderRadius: "15px" }}>
      <Card.Header className="border-0" style={{ backgroundColor: COLORS.light, borderRadius: "15px 15px 0 0" }}>
        <h6 className="mb-0 fw-bold" style={{ color: COLORS.pink }}>
          Comprehension Questions
          <Badge 
            className="ms-2"
            style={{ 
              color: "white",
              borderRadius: "15px",
              padding: "2px 8px",
              fontSize: "0.7rem"
            }}
          >
            {Array.isArray(formData.comprehensionQuestions) ? formData.comprehensionQuestions.length : 0}
          </Badge>
        </h6>
      </Card.Header>
      <Card.Body className="p-4">
        {Array.isArray(formData.comprehensionQuestions) && formData.comprehensionQuestions.length > 0 ? (
          <div className="w-100">
            {formData.comprehensionQuestions.map((q, idx) => (
              <div key={`cq-${idx}`} className="mb-4 p-4 border-0 shadow-sm" style={{ borderRadius: "12px", backgroundColor: '#fdf7fd' }}>
                
                {/* Comprehension Question Image Upload */}
                <Form.Group className="mb-3">
                  <Form.Label className="fw-medium small">Image for Question {idx + 1} (Optional)</Form.Label>
                  <Form.Control type="file" size="sm" accept="image/*" onChange={(e) => handleAssessmentImageUpload(e, 'comprehensionQuestions', idx)} />
                  {(q.imagePreviewUrl || q.imageUrl) && (
                    <div className="mt-2">
                      <img 
                        src={q.imagePreviewUrl || q.imageUrl} 
                        alt={`Preview for question ${idx + 1}`} 
                        style={{ width: '80px', height: '80px', objectFit: 'cover', borderRadius: '8px' }} 
                      />
                    </div>
                  )}
                </Form.Group>

                {/* Question Field - Full Width */}
                <Form.Group className="mb-4">
                  <Form.Label className="fw-semibold">Question {idx + 1}</Form.Label>
                  <Form.Control
                    type="text"
                    value={q.question || ""}
                    onChange={e => {
                      const updatedQuestions = [...formData.comprehensionQuestions];
                      updatedQuestions[idx].question = e.target.value;
                      setFormData(prev => ({
                        ...prev,
                        comprehensionQuestions: updatedQuestions
                      }));
                    }}
                    placeholder={`Enter question ${idx + 1}`}
                    disabled={isGeneratingMoral || isSubmitting}
                    className="border-0 shadow-sm"
                    style={{ borderRadius: "10px" }}
                  />
                </Form.Group>
                
                {/* Options - Full Width */}
                <Row className="g-2">
                  {q.options.map((option, oidx) => (
                    <Col xs={12} key={`cq${idx}-option-${oidx}`}>
                      <InputGroup>
                        <Form.Control
                          type="text"
                          value={option || ""}
                          onChange={e => {
                            const updatedQuestions = [...formData.comprehensionQuestions];
                            updatedQuestions[idx].options[oidx] = e.target.value;
                            setFormData(prev => ({
                              ...prev,
                              comprehensionQuestions: updatedQuestions
                            }));
                          }}
                          placeholder={`Option ${String.fromCharCode(65 + oidx)}`}
                          disabled={isGeneratingMoral || isSubmitting}
                          className="border-0 shadow-sm"
                          style={{ 
                            backgroundColor: q.correctOptionIndex === oidx ? '#FFE4E1' : 'white',
                            borderColor: COLORS.pink,
                            borderRadius: "10px 0 0 10px"
                          }}
                        />
                        <InputGroup.Text 
                          className="shadow-sm"
                          style={{ 
                            backgroundColor: q.correctOptionIndex === oidx ? COLORS.pink : COLORS.light,
                            color: q.correctOptionIndex === oidx ? 'white' : COLORS.dark,
                            borderRadius: "0 10px 10px 0",
                            borderColor: COLORS.pink,
                            fontWeight: '500',
                            fontSize: '0.75rem',
                            minWidth: "90px",
                            cursor: 'pointer'
                          }}
                          onClick={() => {
                            const updatedQuestions = [...formData.comprehensionQuestions];
                            updatedQuestions[idx].correctOptionIndex = oidx;
                            setFormData(prev => ({
                              ...prev,
                              comprehensionQuestions: updatedQuestions
                            }));
                          }}
                        >
                          {q.correctOptionIndex === oidx ? "Correct" : "Incorrect"}
                        </InputGroup.Text>
                      </InputGroup>
                    </Col>
                  ))}
                </Row>
              </div>
            ))}
          </div>
        ) : (
          <div className="text-center py-5">
            <BookFill size={32} className="text-muted mb-2" opacity={0.3} />
            <p className="text-muted mb-0">No comprehension questions generated yet.</p>
            <small className="text-muted">Upload a PDF to auto-generate questions</small>
          </div>
        )}
      </Card.Body>
    </Card>
  </div>
</Modal.Body>
        <Modal.Footer className="border-0 p-4">
          <Row className="w-100">
            <Col>
              <Button
                variant="outline-light"
                className="w-100"
                onClick={handleCloseModal}
                disabled={isSubmitting}
                style={{ 
                  borderColor: COLORS.pink, 
                  color: COLORS.pink,
                  borderRadius: "25px",
                  padding: "12px",
                  fontWeight: "500"
                }}
              >
                Cancel
              </Button>
            </Col>
            <Col>
              <Button
                className="w-100"
                onClick={handleSubmit}
                disabled={isSubmitting}
                style={{
                  backgroundColor: COLORS.pink,
                  border: "none",
                  borderRadius: "25px",
                  padding: "12px",
                  fontWeight: "500"
                }}
              >
                {isSubmitting ? (
                  <>
                    <Spinner as="span" animation="border" size="sm" role="status" aria-hidden="true" className="me-2" />
                    {isEditing ? "Updating..." : "Creating..."}
                  </>
                ) : isEditing ? "Update Story" : "Create Story"}
              </Button>
            </Col>
          </Row>
        </Modal.Footer>
      </Modal>

      {/* Delete Confirmation Modal */}
      <Modal show={showDeleteModal} onHide={() => setShowDeleteModal(false)} size="sm" centered>
        <Modal.Header 
          className="border-0 text-white"
          style={{ background: `linear-gradient(135deg, ${COLORS.pink} 0%, ${COLORS.secondary} 100%)` }}
        >
          <Modal.Title className="w-100 text-center fw-bold">Delete Story</Modal.Title>
          <Button
            variant="link"
            onClick={() => setShowDeleteModal(false)}
            className="btn-close btn-close-white"
            style={{ position: "absolute", top: "18px", right: "18px", filter: "invert(1)", opacity: 0.8 }}
          />
        </Modal.Header>
        <Modal.Body className="text-center p-4">
          <div className="mb-3">
            <TrashFill size={48} style={{ color: COLORS.pink }} />
          </div>
          <h5 className="mb-3">Delete Story?</h5>
          <p className="text-muted mb-0">
            Are you sure you want to delete <strong>"{selectedStory?.title}"</strong>?
          </p>
          <p className="text-muted small mt-2">This action cannot be undone.</p>
        </Modal.Body>
        <Modal.Footer className="border-0 justify-content-center">
          <Button
            variant="secondary"
            onClick={() => setShowDeleteModal(false)}
            style={{ borderRadius: "25px", minWidth: "100px" }}
          >
            Cancel
          </Button>
          <Button
            style={{
              backgroundColor: COLORS.pink,
              border: "none",
              borderRadius: "25px", 
              minWidth: "100px",
              color: "white"
            }}
            onClick={confirmDelete}
          >
            Delete
          </Button>
        </Modal.Footer>
      </Modal>
    </div>
  );
};

export default ManageStories;
